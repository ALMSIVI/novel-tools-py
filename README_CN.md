# 小说整理工具

## 为什么要做这个工具

首先声明，本人支持正版，在可能的情况下，请上官网订阅作者。我的这套工具基本都用于全本订阅的小说。

但是，起点等网站会因各种原因下架小说的部分/全部章节，严重影响阅读体验。在这种情况下，不得不在网络上下载txt版本。txt本身没有格式，如果你是随便读读，那并没有多大问题。但如果你希望将小说转换为更适合电子书的格式（如epub），那么就会出问题。即使部分阅读软件有格式匹配能够自动生成目录，但部分问题仍然无法解决：

- 无法支持自定义格式的卷名/章节名。

某些小说可能不会采用正统的章节名。例如：「少女之战第X幕」。

- 由于作者疏忽，章节名会有重复/遗漏。

例如出现两个100章，或者100章之后直接变成102章。

- 章节名字的格式不规则。

比如中文数字与阿拉伯数字混用，或者「章」后面是否有空格。

对于强迫症患者来说，这是无法接受的。虽然每个小说的问题各不相同，不太可能可以用一套通用的脚本来处理所有的小说，但是脚本至少可以对章节进行简单的自动分割，再进行手动调整。

## 依赖

你需要`natsort`来对数字进行自然排序（1, 2, ..., 10, 11而非1, 10, 11, ..., 2）。

```shell
pip3 install natsort
```

## 使用方法

- 所有的脚本都有`argparse`，可以通过`-h`参数来查看使用指南。

小说下载下来之后，先删去前后的网站声明、书名、简介等无关内容，只留下卷名和章节名。同时确保文件为**utf8**编码，而非gb2312。

### 分割txt

首先，使用`split.py`对txt文件进行分卷、分章节。如果小说没有分卷，那么默认会加入“正文”分卷。同时会检测重复或遗漏的分卷/章节名，并在命令行中输出。你可以通过`-c`选项自动修正，也可以根据输出来手动对分卷名或章节名进行调整。

使用方式如下：

```shell
python3 split.py -f FILENAME [-o OUT_DIR] [-d] [-c] [-l] [-h]
```

其中`-f`是小说文件名，为必选参数，其余为可选参数。`-d`可以控制重复/遗漏名称检测模块中，在分卷间是否抛弃章节的id。有些小说的分卷会连续编号，而有些小说每一卷都会从第一章开始重新编号。`-c`可以控制自动修正重复/缺失的目录。`-l`会使程序打印所有识别出来的卷名和章节名，而不实际对文件进行分割。这样你可以在正式分割前检查目录结构，并进行必要的修改。最后，`-o`在分割模式下指定输出路径，默认为小说所在的路径；在打印模式下指定输出文件，默认会打印在命令行中。

`split.py`通过不同的**Matcher**来识别卷名和章节名。匹配过程中，文件的每一行都会被传入指定的Matcher中，提取两部分：“序号”（index）和“标题”（title）。

- 例如，若某一行为“第五章 新生”，那么配置完善的`NumberedMatcher`可以提取序号“5“（整数），标题”新生“。

Matcher还定义了两个方法：

- `format()`接收匹配结果（序号和标题），对卷名/章节名重新格式化。在章节名有重复、遗漏的情况下，使用这个方法进行自动修正。
- `filename()`接受匹配结果（序号和标题），输出合法的文件名。最基础的实现即为在`format()`返回的字符串中移除所有非法字符。

目前一共有三个不同的`Matcher`实现，你也可以根据自己需求添加更多。当`split.py`运行时，脚本默认会从当前工作目录下的`default_matchers.json`中获取`Matcher`及其参数。如果你需要对小说进行单独配置，可以将该文件复制到小说目录下，更名为`matchers.json`后进行修改，脚本会自动识别该文件并创建相应的`Matcher`。

- `NumberedMatcher`：匹配正则表达式，识别章节名中的数字，并将中文数字转换成阿拉伯数字（以便于排序）。json规范如下：

```json
{
    "class": "NumberedMatcher", // 脚本内部使用
    "regex": "^第(.+)章(.*)$", // 需要两个正则表达式分组：第一个为序号，第二个为标题
    "format": "第{index}章 {title}", // 你并不需要包括序号和标题
}
```

- `SpecialMatcher`：匹配给定的特殊前缀列表，例如”引子“、”终章“等。在指定了前缀后，脚本会给每一个前缀分配一个负序号（以免与正常分卷/章节混淆）。即使你使用了`-c`选项，带有负序号的分卷/章节也**不会**被验证或自动修正。json规范如下：

```json
{
    "class": "SpecialMatcher", // 脚本内部使用
    "prefixes":["前传", "最终卷", "后记", "番外篇"],
    "regex": "^{prefixes}(.*)$", // 脚本会自动为前缀生成正则表达式，你只需要对标题进行分组
    "format": "{prefix}. {title}", // 你并不需要包括序号和标题
}
```

- `VolumeMatcher`：匹配不规则的分卷名。你不需要自己生成这个Matcher；你需要在小说目录生成一个`volumes.json`来声明卷名，脚本会自动生成一个Matcher。若脚本检测到`volumes.json`，那么所有默认及用户自定义的分卷Matcher都会**被忽略**。json规范如下：
  
  ```json
  [
      {
          "name": "生成分卷的文件夹名（需要是合法的文件夹名）",
          "volume": "小说原文件中中分卷的标题",
          "volume_formatted": "格式化后的标题（可选）"
      },
  ]
  ```

如果你的分卷名比较规则，可以被匹配到，但需要手动排序，那么你可以在用`split.py`生成所有分卷文件夹后，再使用`generate_order.py`来自动生成这个json文件。该脚本接受一个`-d`参数，指名小说分卷文件夹的根目录。如果分卷的名字不规则，不符合自然排序规则，那么需要手动生成`volumes.json`并对分卷进行排序。

-----

如果小说的分卷有简介，那么将其存为`_intro.txt`并放入各自的分卷目录中。因为章节会自然排序，前面的下划线可以保证简介文件在合并时被第一个读取。对于小说的简介，将`_intro.txt`放入主目录下。在合并时脚本会自动检测该文件并将其放入合并过后的文档中。

### 合并分卷/章节

然后，你就可以使用`concatenate.py`来合并所有的分卷/章节，保存到一个统一的Markdown文件中。

使用方式如下：

```shell
python3 concatenate.py -i IN_DIR [-o OUT_DIR] [-t TITLE_HEADING] [-v VOLUME_HEADING] [-c CHAPTER_HEADING] [-a]
```

其中`-i`是小说目录，为必选参数，其余的参数均可选。`-o`指定输出路径（默认为小说路径）；`-t`，`-v`，`-c`分别指小说、分卷和章节的标题格式（h1-h6）；`-a`可以让你控制是否需要将分卷名添加到合并后的文件中。如果小说没有分卷，保存在**正文**文件夹下，那么你可以使用此选项。

**注意**：在使用`-a`后，章节标题会默认提升一级。

### 转换格式，导入Calibre

现在，你就可以将整理完成的文件导入到Calibre等电子书管理软件中，统一进行管理。你可以手动操作，亦可以使用`add_to_calibre.py`和`calibre_convert.py`。这两个脚本均接受一个`-d`参数，指明小说所在目录。对于这两个脚本，你需要下载一张封面图，保存为`cover.jpg`，同时需要手动生成一个`metadata.json`文件以保存元信息，模板如下：

```json
{
    "title": "My Favorite Book",
    "author": "Best author in the world",
    "id": "isbn:1234567890",
    "tags": ["Fiction"],
    "publisher": "Hello World",
    "languages": ["English"]
}
```
